package scala.meta
package internal
package quasiquotes

import scala.runtime.ScalaRunTime
import scala.quoted._
import scala.meta.{Tree => MetaTree}
import scala.meta.internal.trees.Quasi
import scala.meta.internal.parsers.Absolutize._
import scala.meta.internal.parsers.Messages

import scala.collection.mutable
import scala.annotation.tailrec

// uses holes in implementation, for which we do not have access here
trait InternalTrait(using Quotes) {
  def liftTree(tree: MetaTree)(using Quotes): Expr[Any]
  def liftOptionTree(maybeTree: Option[MetaTree]): Expr[Option[Any]]
  def liftTrees[T: Type](trees: Seq[MetaTree])(using Quotes): Expr[List[Any]]
  def liftQuasi0(quasi: Quasi, optional: Boolean = false): Expr[Any]

  protected def unquotesName(q: scala.meta.internal.trees.Quasi): Boolean
}

// TODO should be generated by a custom codegen script
trait ExprLifts(using Quotes) extends ReificationMacros with InternalTrait { 
  import quotes.reflect._

  given liftableSubTree[T <: MetaTree]: ToExpr[T] with {
    def apply(tree: T)(using Quotes) =
      liftableSubTree0(tree)
  }
  given liftableSubSeqTree[T <: MetaTree: Type]: ToExpr[Seq[T]] with {
    def apply(tree: Seq[T])(using Quotes) =
      liftTrees(tree).asExprOf[Seq[T]]
  }
  given liftableSubTrees[T <: MetaTree: Type]: ToExpr[List[T]] with {
    def apply(tree: List[T])(using Quotes) = liftTrees[T](tree).asInstanceOf[Expr[List[T]]]
  }
  given liftableSubSeqTrees[T <: MetaTree]: ToExpr[Seq[List[T]]] with {
    def apply(tree: Seq[List[T]])(using Quotes) = ???//Lifts.liftTreess(tree)
  }
  given liftableSubTreess[T <: MetaTree]: ToExpr[List[List[T]]] with {
    def apply(tree: List[List[T]])(using Quotes) = ???//Lifts.liftTreess(tree)
  }
  given liftableOptionSubTree[T <: MetaTree]: ToExpr[Option[T]] with {
    def apply(tree: Option[T])(using Quotes) = liftOptionTree(tree).asInstanceOf[Expr[Option[T]]]
  }

  def liftQuasi(y: scala.meta.internal.trees.Quasi) = liftQuasi0(y);
  def liftTypeFuncParamClause(y: scala.meta.Type.FuncParamClause) = '{scala.meta.Type.FuncParamClause(${Expr(y.values)})}
  def liftTypeBounds(y: scala.meta.Type.Bounds) = '{scala.meta.Type.Bounds(${Expr(y.lo)}, ${Expr(y.hi)})}
  def liftMemberParamClauseGroup(y: scala.meta.Member.ParamClauseGroup) = '{scala.meta.Member.ParamClauseGroup(${Expr(y.tparamClause)}, ${Expr(y.paramClauses)})}
  def liftTemplate(y: scala.meta.Template) = '{scala.meta.Template(${Expr(y.early)}, ${Expr(y.inits)}, ${Expr(y.self)}, ${Expr(y.stats)}, ${Expr(y.`derives`)})}
  def liftImporter(y: scala.meta.Importer) = '{scala.meta.Importer(${Expr(y.ref)}, ${Expr(y.importees)})}
  def liftSource(y: scala.meta.Source) = '{scala.meta.Source(${Expr(y.stats)})}
  def liftMultiSource(y: scala.meta.MultiSource) = '{scala.meta.MultiSource(${Expr(y.sources)})}
  def liftInit(y: scala.meta.Init) = '{scala.meta.Init(${Expr(y.tpe)}, ${Expr(y.name)}, ${Expr(y.argClauses)})}
  def liftNameAnonymous(y: scala.meta.Name.Anonymous) = '{scala.meta.Name.Anonymous()}
  def liftNameThis(y: scala.meta.Name.This) = '{scala.meta.Name.This()}
  def liftNameIndeterminate(y: scala.meta.Name.Indeterminate) = '{scala.meta.Name.Indeterminate(${Expr(y.value)})}
  def liftNamePlaceholder(y: scala.meta.Name.Placeholder) = '{scala.meta.Name.Placeholder()}
  def liftTermName(y: scala.meta.Term.Name) = '{scala.meta.Term.Name(${Expr(y.value)})}
  def liftTermAnonymous(y: scala.meta.Term.Anonymous) = '{scala.meta.Term.Anonymous()}
  def liftTypeName(y: scala.meta.Type.Name) = '{scala.meta.Type.Name(${Expr(y.value)})}
  def liftTermThis(y: scala.meta.Term.This) = '{scala.meta.Term.This(${Expr(y.qual)})}
  def liftTermSuper(y: scala.meta.Term.Super) = '{scala.meta.Term.Super(${Expr(y.thisp)}, ${Expr(y.superp)})}
  def liftTermSelect(y: scala.meta.Term.Select) = '{scala.meta.Term.Select(${Expr(y.qual)}, ${Expr(y.name)})}
  def liftTermApplyUnary(y: scala.meta.Term.ApplyUnary) = '{scala.meta.Term.ApplyUnary(${Expr(y.op)}, ${Expr(y.arg)})}
  def liftTypeSelect(y: scala.meta.Type.Select) = '{scala.meta.Type.Select(${Expr(y.qual)}, ${Expr(y.name)})}
  def liftTypeProject(y: scala.meta.Type.Project) = '{scala.meta.Type.Project(${Expr(y.qual)}, ${Expr(y.name)})}
  def liftTypeSingleton(y: scala.meta.Type.Singleton) = '{scala.meta.Type.Singleton(${Expr(y.ref)})}
  def liftImporteeWildcard(y: scala.meta.Importee.Wildcard) = '{scala.meta.Importee.Wildcard()}
  def liftImporteeGiven(y: scala.meta.Importee.Given) = '{scala.meta.Importee.Given(${Expr(y.tpe)})}
  def liftImporteeGivenAll(y: scala.meta.Importee.GivenAll) = '{scala.meta.Importee.GivenAll()}
  def liftImporteeName(y: scala.meta.Importee.Name) = '{scala.meta.Importee.Name(${Expr(y.name)})} 
  def liftImporteeRename(y: scala.meta.Importee.Rename) = '{scala.meta.Importee.Rename(${Expr(y.name)}, ${Expr(y.rename)})}
  def liftImporteeUnimport(y: scala.meta.Importee.Unimport) = '{scala.meta.Importee.Unimport(${Expr(y.name)})}
  def liftTypeAnonymousName(y: scala.meta.Type.AnonymousName) = '{scala.meta.Type.AnonymousName()}
  def liftTypeApply(y: scala.meta.Type.Apply) = '{scala.meta.Type.Apply(${Expr(y.tpe)}, ${Expr(y.argClause)})}
  def liftTypeApplyInfix(y: scala.meta.Type.ApplyInfix) = '{scala.meta.Type.ApplyInfix(${Expr(y.lhs)}, ${Expr(y.op)}, ${Expr(y.rhs)})}
  def liftTypePolyFunction(y: scala.meta.Type.PolyFunction) = '{scala.meta.Type.PolyFunction(${Expr(y.tparamClause)}, ${Expr(y.tpe)})}
  def liftTypeImplicitFunction(y: scala.meta.Type.ImplicitFunction) = '{scala.meta.Type.ImplicitFunction(${Expr(y.params)}, ${Expr(y.res)})}
  def liftTypeTuple(y: scala.meta.Type.Tuple) = '{scala.meta.Type.Tuple(${Expr(y.args)})}
  def liftTypeWith(y: scala.meta.Type.With) = '{scala.meta.Type.With(${Expr(y.lhs)}, ${Expr(y.rhs)})}
  def liftTypeAnd(y: scala.meta.Type.And) = '{scala.meta.Type.And(${Expr(y.lhs)}, ${Expr(y.rhs)})}
  def liftTypeOr(y: scala.meta.Type.Or) = '{scala.meta.Type.Or(${Expr(y.lhs)}, ${Expr(y.rhs)})}
  def liftTypeRefine(y: scala.meta.Type.Refine) = '{scala.meta.Type.Refine(${Expr(y.tpe)}, ${Expr(y.stats)})}
  def liftTypeExistential(y: scala.meta.Type.Existential) = '{scala.meta.Type.Existential(${Expr(y.tpe)}, ${Expr(y.stats)})}
  def liftTypeAnnotate(y: scala.meta.Type.Annotate) = '{scala.meta.Type.Annotate(${Expr(y.tpe)}, ${Expr(y.annots)})}
  def liftTypeLambda(y: scala.meta.Type.Lambda) = '{scala.meta.Type.Lambda(${Expr(y.tparamClause)}, ${Expr(y.tpe)})}
  def liftTypeAnonymousLambda(y: scala.meta.Type.AnonymousLambda) = '{scala.meta.Type.AnonymousLambda(${Expr(y.tpe)})}
  def liftTypeMacro(y: scala.meta.Type.Macro) = '{scala.meta.Type.Macro(${Expr(y.body)})}
  def liftTypeMethod(y: scala.meta.Type.Method) = '{scala.meta.Type.Method(${Expr(y.paramClauses)}, ${Expr(y.tpe)})}
  def liftTypePatWildcard(y: scala.meta.Type.PatWildcard) = '{scala.meta.Type.PatWildcard()}
  def liftTypeByName(y: scala.meta.Type.ByName) = '{scala.meta.Type.ByName(${Expr(y.tpe)})}
  def liftTypeRepeated(y: scala.meta.Type.Repeated) = '{scala.meta.Type.Repeated(${Expr(y.tpe)})}
  def liftTypeVar(y: scala.meta.Type.Var) = '{scala.meta.Type.Var(${Expr(y.name)})}
  def liftTypeMatch(y: scala.meta.Type.Match) = '{scala.meta.Type.Match(${Expr(y.tpe)}, ${Expr(y.cases)})}
  def liftLitNull(y: scala.meta.Lit.Null) = '{scala.meta.Lit.Null()}
  def liftLitInt(y: scala.meta.Lit.Int) = '{scala.meta.Lit.Int(${Expr(y.value)})}
  def liftLitDouble(y: scala.meta.Lit.Double) = '{scala.meta.Lit.Double(${Expr(y.format)})}
  def liftLitFloat(y: scala.meta.Lit.Float) = '{scala.meta.Lit.Float(${Expr(y.format)})}
  def liftLitByte(y: scala.meta.Lit.Byte) = '{scala.meta.Lit.Byte(${Expr(y.value)})}
  def liftLitShort(y: scala.meta.Lit.Short) = '{scala.meta.Lit.Short(${Expr(y.value)})}
  def liftLitChar(y: scala.meta.Lit.Char) = '{scala.meta.Lit.Char(${Expr(y.value)})}
  def liftLitLong(y: scala.meta.Lit.Long) = '{scala.meta.Lit.Long(${Expr(y.value)})}
  def liftLitBoolean(y: scala.meta.Lit.Boolean) = '{scala.meta.Lit.Boolean(${Expr(y.value)})}
  def liftLitUnit(y: scala.meta.Lit.Unit) = '{scala.meta.Lit.Unit()}
  def liftLitString(y: scala.meta.Lit.String) = '{scala.meta.Lit.String(${Expr(y.value)})}
  // def liftLitSymbol(y: scala.meta.Lit.Symbol) = '{scala.meta.Lit.Symbol(${Expr(y.value)})}
  def liftTypeFunction(y: scala.meta.Type.Function) = '{scala.meta.Type.Function(${Expr(y.paramClause)}, ${Expr(y.res)})}
  def liftTypeContextFunction(y: scala.meta.Type.ContextFunction) = '{scala.meta.Type.ContextFunction(${Expr(y.paramClause)}, ${Expr(y.res)})}
  def liftTypePlaceholderImpl(y: scala.meta.Type.Placeholder.Impl) = '{scala.meta.Type.Placeholder.Impl(${Expr(y.bounds)})}
  def liftTypeWildcard(y: scala.meta.Type.Wildcard) = '{scala.meta.Type.Wildcard(${Expr(y.bounds)})}
  def liftTypeAnonymousParam(y: scala.meta.Type.AnonymousParam) = '{scala.meta.Type.AnonymousParam(${Expr(y.variant)})}
  def liftTypeTypedParam(y: scala.meta.Type.TypedParam) = '{scala.meta.Type.TypedParam(${Expr(y.name)}, ${Expr(y.typ)}, ${Expr(y.mods)})}
  def liftTypeFunctionArg(y: scala.meta.Type.FunctionArg) = '{scala.meta.Type.FunctionArg(${Expr(y.mods)}, ${Expr(y.tpe)})}
  def liftPatVar(y: scala.meta.Pat.Var) = '{scala.meta.Pat.Var(${Expr(y.name)})}
  def liftPatWildcard(y: scala.meta.Pat.Wildcard) = '{scala.meta.Pat.Wildcard()}
  def liftPatSeqWildcard(y: scala.meta.Pat.SeqWildcard) = '{scala.meta.Pat.SeqWildcard()}
  def liftPatBind(y: scala.meta.Pat.Bind) = {
    {
      import quotes.reflect._
      def prohibitName(pat: scala.meta.Tree): Unit = {
        pat match {
          case (q @ (_: scala.meta.internal.trees.Quasi)) if unquotesName(q) => {
            val action =
              if (q.rank == 0) "unquote"
              else "splice"
            report.errorAndAbort("can\'t " + action + " a name here, use a pattern instead (e.g. p\"x\")")//, q.pos)
          }
          case _ => ()
        }
      };
      prohibitName(y.lhs)
    }
    '{scala.meta.Pat.Bind(${Expr(y.lhs)}, ${Expr(y.rhs)})}
  }
  def liftPatAlternative(y: scala.meta.Pat.Alternative) = '{scala.meta.Pat.Alternative(${Expr(y.lhs)}, ${Expr(y.rhs)})}
  def liftPatTuple(y: scala.meta.Pat.Tuple) = '{scala.meta.Pat.Tuple(${Expr(y.args)})}
  def liftPatRepeated(y: scala.meta.Pat.Repeated) = '{scala.meta.Pat.Repeated(${Expr(y.name)})}
  def liftPatExtract(y: scala.meta.Pat.Extract) = '{scala.meta.Pat.Extract(${Expr(y.fun)}, ${Expr(y.argClause)})}
  def liftPatExtractInfix(y: scala.meta.Pat.ExtractInfix) = '{scala.meta.Pat.ExtractInfix(${Expr(y.lhs)}, ${Expr(y.op)}, ${Expr(y.argClause)})}
  def liftPatInterpolate(y: scala.meta.Pat.Interpolate) = '{scala.meta.Pat.Interpolate(${Expr(y.prefix)}, ${Expr(y.parts)}, ${Expr(y.args)})}
  def liftPatXml(y: scala.meta.Pat.Xml) = '{scala.meta.Pat.Xml(${Expr(y.parts)}, ${Expr(y.args)})}
  def liftPatTyped(y: scala.meta.Pat.Typed) = {
    {
      import quotes.reflect._
      def prohibitName(pat: scala.meta.Tree): Unit = {
        pat match {
          case (q @ (_: scala.meta.internal.trees.Quasi)) if unquotesName(q) => {
            val action =
              if (q.rank == 0) "unquote"
              else "splice"
            report.errorAndAbort("can\'t " + action + " a name here, use a pattern instead (e.g. p\"x\")")//, q.pos)
          }
          case _ => ()
        }
      }
      prohibitName(y.lhs)
    }
    '{scala.meta.Pat.Typed(${Expr(y.lhs)}, ${Expr(y.rhs)})}
  };
  def liftPatMacro(y: scala.meta.Pat.Macro) = '{scala.meta.Pat.Macro(${Expr(y.body)})}
  def liftPatGiven(y: scala.meta.Pat.Given) = '{scala.meta.Pat.Given(${Expr(y.tpe)})}
  def liftPkg(y: scala.meta.Pkg) = '{scala.meta.Pkg(${Expr(y.ref)}, ${Expr(y.stats)})}
  def liftPkgObject(y: scala.meta.Pkg.Object) = '{scala.meta.Pkg.Object(${Expr(y.mods)}, ${Expr(y.name)}, ${Expr(y.templ)})}
  def liftCtorSecondary(y: scala.meta.Ctor.Secondary) = '{scala.meta.Ctor.Secondary(${Expr(y.mods)}, ${Expr(y.name)}, ${Expr(y.paramClauses)}, ${Expr(y.init)}, ${Expr(y.stats)})}
  def liftTermInterpolate(y: scala.meta.Term.Interpolate) = '{scala.meta.Term.Interpolate(${Expr(y.prefix)}, ${Expr(y.parts)}, ${Expr(y.args)})}
  def liftTermXml(y: scala.meta.Term.Xml) = '{scala.meta.Term.Xml(${Expr(y.parts)}, ${Expr(y.args)})}
  def liftTermApply(y: scala.meta.Term.Apply) = {
    object ApplyToTripleDots extends scala.AnyRef {
      def unapply(t: scala.meta.Term.Apply): Option[scala.Tuple2[scala.meta.Term, scala.Either[scala.meta.Term.Quasi, scala.meta.Term.ArgClause.Quasi]]] = t.argClause match {
        case (arg @ (_: scala.meta.Term.ArgClause.Quasi)) if arg.rank == 1 => scala.Some(scala.Tuple2(t.fun, scala.Right(arg)))
        case scala.List((arg @ (_: scala.meta.Term.Quasi))) if arg.rank == (2) => scala.Some(scala.Tuple2(t.fun, scala.Left(arg)))
        case _ => scala.None
      }
    }
    @tailrec() def checkNoTripleDots(fn: scala.meta.Term, arg: scala.meta.internal.trees.Quasi): Unit = fn match {
      case (t @ (_: scala.meta.Term.Apply)) => ApplyToTripleDots.unapply(t) match {
        case scala.None => checkNoTripleDots(t.fun, arg)
        case _ => ???//c.abort(arg.pos, _root_.scala.meta.internal.parsers.Messages.QuasiquoteAdjacentEllipsesInPattern(arg.rank))
      }
      case _ => ()
    };
    def applyTermQuasi(fn: scala.meta.Term)(arg: scala.meta.Term.Quasi) = {
      checkNoTripleDots(fn, arg)
      '{scala.meta.internal.trees.Syntactic.TermApply.ArgListList(${Expr(fn)}, ${Expr(List(List(arg)))})}
      // c.universe.Apply(c.universe.Select(c.universe.Select(c.universe.Select(c.universe.Select(c.universe.Select(c.universe.Select(c.universe.Select(c.universe.Ident(c.universe.TermName("_root_")), c.universe.TermName("scala")), c.universe.TermName("meta")), c.universe.TermName("internal")), c.universe.TermName("trees")), c.universe.TermName("Syntactic")), c.universe.TermName("TermApply")), c.universe.TermName("ArgListList")), _root_.scala.List(_root_.scala.Predef.implicitly[c.universe.Liftable[_root_.scala.meta.Term]].apply(fn), _root_.scala.Predef.implicitly[c.universe.Liftable[List[List[_root_.scala.meta.Term.Quasi]]]].apply(List(List(arg)))))
    }
    def applyArgClauseQuasi(fn: _root_.scala.meta.Term)(arg: _root_.scala.meta.Term.ArgClause.Quasi) = {
      checkNoTripleDots(fn, arg)
      '{scala.meta.internal.trees.Syntactic.TermApply.ArgList(${Expr(fn)}, ${Expr(List(arg))})}
      // c.universe.Apply(c.universe.Select(c.universe.Select(c.universe.Select(c.universe.Select(c.universe.Select(c.universe.Select(c.universe.Select(c.universe.Ident(c.universe.TermName("_root_")), c.universe.TermName("scala")), c.universe.TermName("meta")), c.universe.TermName("internal")), c.universe.TermName("trees")), c.universe.TermName("Syntactic")), c.universe.TermName("TermApply")), c.universe.TermName("ArgList")), _root_.scala.List(_root_.scala.Predef.implicitly[c.universe.Liftable[_root_.scala.meta.Term]].apply(fn), _root_.scala.Predef.implicitly[c.universe.Liftable[List[_root_.scala.meta.Term.ArgClause.Quasi]]].apply(List(arg))))
    }
    y match {
      case ApplyToTripleDots((fn @ _), (either @ _)) => either.fold(applyTermQuasi(fn), applyArgClauseQuasi(fn))
      case _ => '{scala.meta.Term.Apply(${Expr(y.fun)}, ${Expr(y.argClause)})}
    }
  }
  def liftTermApplyUsing(y: scala.meta.Term.ApplyUsing) = '{scala.meta.Term.ApplyUsing(${Expr(y.fun)}, ${Expr(y.argClause)})}
  def liftTermApplyType(y: scala.meta.Term.ApplyType)(using Quotes) = '{scala.meta.Term.ApplyType(${Expr(y.fun)}, ${Expr(y.targClause)})}
  def liftTermApplyInfix(y: scala.meta.Term.ApplyInfix) = '{scala.meta.Term.ApplyInfix(${Expr(y.lhs)}, ${Expr(y.op)}, ${Expr(y.targClause)}, ${Expr(y.argClause)})}
  def liftTermAssign(y: scala.meta.Term.Assign) = '{scala.meta.Term.Assign(${Expr(y.lhs)}, ${Expr(y.rhs)})}
  def liftTermReturn(y: scala.meta.Term.Return) = '{scala.meta.Term.Return(${Expr(y.expr)})}
  def liftTermThrow(y: scala.meta.Term.Throw) = '{scala.meta.Term.Throw(${Expr(y.expr)})}
  def liftTermAscribe(y: scala.meta.Term.Ascribe) = '{scala.meta.Term.Ascribe(${Expr(y.expr)}, ${Expr(y.tpe)})}
  def liftTermAnnotate(y: scala.meta.Term.Annotate) = '{scala.meta.Term.Annotate(${Expr(y.expr)}, ${Expr(y.annots)})}
  def liftTermTuple(y: scala.meta.Term.Tuple) = '{scala.meta.Term.Tuple(${Expr(y.args)})}
  def liftTermBlock(y: scala.meta.Term.Block) = '{scala.meta.Term.Block(${Expr(y.stats)})}
  def liftTermEndMarker(y: scala.meta.Term.EndMarker) = '{scala.meta.Term.EndMarker(${Expr(y.name)})}
  def liftTermIf(y: scala.meta.Term.If) = '{scala.meta.Term.If(${Expr(y.cond)}, ${Expr(y.thenp)}, ${Expr(y.elsep)}, ${Expr(y.mods)})}
  def liftTermQuotedMacroExpr(y: scala.meta.Term.QuotedMacroExpr) = '{scala.meta.Term.QuotedMacroExpr(${Expr(y.body)})}
  def liftTermQuotedMacroType(y: scala.meta.Term.QuotedMacroType) = '{scala.meta.Term.QuotedMacroType(${Expr(y.tpe)})}
  def liftTermSplicedMacroExpr(y: scala.meta.Term.SplicedMacroExpr) = '{scala.meta.Term.SplicedMacroExpr(${Expr(y.body)})}
  def liftTermSplicedMacroPat(y: scala.meta.Term.SplicedMacroPat) = '{scala.meta.Term.SplicedMacroPat(${Expr(y.pat)})}
  def liftTermMatch(y: scala.meta.Term.Match) = '{scala.meta.Term.Match(${Expr(y.expr)}, ${Expr(y.cases)}, ${Expr(y.mods)})}
  def liftTermTry(y: scala.meta.Term.Try) = '{scala.meta.Term.Try(${Expr(y.expr)}, ${Expr(y.catchp)}, ${Expr(y.finallyp)})}
  def liftTermTryWithHandler(y: scala.meta.Term.TryWithHandler) = '{scala.meta.Term.TryWithHandler(${Expr(y.expr)}, ${Expr(y.catchp)}, ${Expr(y.finallyp)})}
  def liftTermAnonymousFunction(y: scala.meta.Term.AnonymousFunction) = '{scala.meta.Term.AnonymousFunction(${Expr(y.body)})}
  def liftTermPolyFunction(y: scala.meta.Term.PolyFunction) = '{scala.meta.Term.PolyFunction(${Expr(y.tparamClause)}, ${Expr(y.body)})}
  def liftTermPartialFunction(y: scala.meta.Term.PartialFunction) = '{scala.meta.Term.PartialFunction(${Expr(y.cases)})}
  def liftTermWhile(y: scala.meta.Term.While) = '{scala.meta.Term.While(${Expr(y.expr)}, ${Expr(y.body)})}
  def liftTermDo(y: scala.meta.Term.Do) = '{scala.meta.Term.Do(${Expr(y.body)}, ${Expr(y.expr)})}
  def liftTermFor(y: scala.meta.Term.For) = '{scala.meta.Term.For(${Expr(y.enums)}, ${Expr(y.body)})}
  def liftTermForYield(y: scala.meta.Term.ForYield) = '{scala.meta.Term.ForYield(${Expr(y.enums)}, ${Expr(y.body)})}
  def liftTermNew(y: scala.meta.Term.New) = '{scala.meta.Term.New(${Expr(y.init)})}
  def liftTermNewAnonymous(y: scala.meta.Term.NewAnonymous) = '{scala.meta.Term.NewAnonymous(${Expr(y.templ)})}
  def liftTermPlaceholder(y: scala.meta.Term.Placeholder) = '{scala.meta.Term.Placeholder()}
  def liftTermEta(y: scala.meta.Term.Eta) = '{scala.meta.Term.Eta(${Expr(y.expr)})}
  def liftTermRepeated(y: scala.meta.Term.Repeated) = '{scala.meta.Term.Repeated(${Expr(y.expr)})}
  def liftTermContextFunction(y: scala.meta.Term.ContextFunction) = '{scala.meta.Term.ContextFunction(${Expr(y.paramClause)}, ${Expr(y.body)})}
  def liftTermFunction(y: scala.meta.Term.Function) = '{scala.meta.Term.Function(${Expr(y.paramClause)}, ${Expr(y.body)})}
  def liftDefnGiven(y: scala.meta.Defn.Given) = '{scala.meta.Defn.Given(${Expr(y.mods)}, ${Expr(y.name)}, ${Expr(y.paramClauseGroup)}, ${Expr(y.templ)})}
  def liftDefnEnum(y: scala.meta.Defn.Enum) = '{scala.meta.Defn.Enum(${Expr(y.mods)}, ${Expr(y.name)}, ${Expr(y.tparamClause)}, ${Expr(y.ctor)}, ${Expr(y.templ)})}
  def liftDefnClass(y: scala.meta.Defn.Class) = '{scala.meta.Defn.Class(${Expr(y.mods)}, ${Expr(y.name)}, ${Expr(y.tparamClause)}, ${Expr(y.ctor)}, ${Expr(y.templ)})}
  def liftDefnTrait(y: scala.meta.Defn.Trait) = '{scala.meta.Defn.Trait(${Expr(y.mods)}, ${Expr(y.name)}, ${Expr(y.tparamClause)}, ${Expr(y.ctor)}, ${Expr(y.templ)})}
  def liftDefnObject(y: scala.meta.Defn.Object) = '{scala.meta.Defn.Object(${Expr(y.mods)}, ${Expr(y.name)}, ${Expr(y.templ)})}
  def liftDeclVal(y: scala.meta.Decl.Val) = '{scala.meta.Decl.Val(${Expr(y.mods)}, ${Expr(y.pats)}, ${Expr(y.decltpe)})}
  def liftDeclVar(y: scala.meta.Decl.Var) = '{scala.meta.Decl.Var(${Expr(y.mods)}, ${Expr(y.pats)}, ${Expr(y.decltpe)})}
  def liftDeclDef(y: scala.meta.Decl.Def) = '{scala.meta.Decl.Def(${Expr(y.mods)}, ${Expr(y.name)}, ${Expr(y.paramClauseGroups)}, ${Expr(y.decltpe)})}
  def liftDeclType(y: scala.meta.Decl.Type) = '{scala.meta.Decl.Type(${Expr(y.mods)}, ${Expr(y.name)}, ${Expr(y.tparamClause)}, ${Expr(y.bounds)})}
  def liftDeclGiven(y: scala.meta.Decl.Given) = '{scala.meta.Decl.Given(${Expr(y.mods)}, ${Expr(y.name)}, ${Expr(y.paramClauseGroup)}, ${Expr(y.decltpe)})}
  def liftDefnVal(y: scala.meta.Defn.Val) = {
    import quotes.reflect._
    y.pats.foreach(((pat) => {
      def prohibitName(pat: scala.meta.Tree): _root_.scala.Unit = {
        pat match {
          case (q @ (_: scala.meta.internal.trees.Quasi)) if unquotesName(q) => {
            val action =
              if (q.rank == 0) "unquote"
              else "splice"
            report.errorAndAbort("can\'t " + action + " a name here, use a pattern instead (e.g. p\"x\")")//, q.pos)
          }
          case _ => ()
        }
      };
      prohibitName(pat)
    }))
    '{scala.meta.Defn.Val(${Expr(y.mods)}, ${Expr(y.pats)}, ${Expr(y.decltpe)}, ${Expr(y.rhs)})}
  }
  def liftDefnVar(y: scala.meta.Defn.Var) = {
    import quotes.reflect._
    y.pats.foreach(((pat) => {
      def prohibitName(pat: scala.meta.Tree): _root_.scala.Unit = {
        pat match {
          case (q @ (_: scala.meta.internal.trees.Quasi)) if unquotesName(q) => {
            val action =
              if (q.rank == 0) "unquote"
              else "splice"
            report.errorAndAbort("can\'t " + action + " a name here, use a pattern instead (e.g. p\"x\")")//, q.pos)
          }
          case _ => ()
        }
      }
      prohibitName(pat)
    }))
    '{scala.meta.Defn.Var(${Expr(y.mods)}, ${Expr(y.pats)}, ${Expr(y.decltpe)}, ${Expr(y.body)})}
  }
  def liftDefnEnumCase(y: scala.meta.Defn.EnumCase) = '{scala.meta.Defn.EnumCase(${Expr(y.mods)}, ${Expr(y.name)}, ${Expr(y.tparamClause)}, ${Expr(y.ctor)}, ${Expr(y.inits)})}
  def liftDefnRepeatedEnumCase(y: scala.meta.Defn.RepeatedEnumCase) = '{scala.meta.Defn.RepeatedEnumCase(${Expr(y.mods)}, ${Expr(y.cases)})}
  def liftDefnGivenAlias(y: scala.meta.Defn.GivenAlias) = '{scala.meta.Defn.GivenAlias(${Expr(y.mods)}, ${Expr(y.name)}, ${Expr(y.paramClauseGroup)}, ${Expr(y.decltpe)}, ${Expr(y.body)})}
  def liftDefnDef(y: scala.meta.Defn.Def) = '{scala.meta.Defn.Def(${Expr(y.mods)}, ${Expr(y.name)}, ${Expr(y.paramClauseGroups)}, ${Expr(y.decltpe)}, ${Expr(y.body)})}
  def liftDefnMacro(y: scala.meta.Defn.Macro) = '{scala.meta.Defn.Macro(${Expr(y.mods)}, ${Expr(y.name)}, ${Expr(y.paramClauseGroups)}, ${Expr(y.decltpe)}, ${Expr(y.body)})}
  def liftDefnType(y: scala.meta.Defn.Type) = '{scala.meta.Defn.Type(${Expr(y.mods)}, ${Expr(y.name)}, ${Expr(y.tparamClause)}, ${Expr(y.body)}, ${Expr(y.bounds)})}
  def liftDefnExtensionGroup(y: scala.meta.Defn.ExtensionGroup) = '{scala.meta.Defn.ExtensionGroup(${Expr(y.paramClauseGroup)}, ${Expr(y.body)})}
  def liftImport(y: scala.meta.Import) = '{scala.meta.Import(${Expr(y.importers)})}
  def liftExport(y: scala.meta.Export) = '{scala.meta.Export(${Expr(y.importers)})}
  def liftTermArgClause(y: scala.meta.Term.ArgClause) = '{scala.meta.Term.ArgClause(${Expr(y.values)}, ${Expr(y.mod)})}
  def liftTypeArgClause(y: scala.meta.Type.ArgClause)(using Quotes) = '{scala.meta.Type.ArgClause(${Expr(y.values)})}
  def liftPatArgClause(y: scala.meta.Pat.ArgClause)(using Quotes) = '{scala.meta.Pat.ArgClause(${Expr(y.values)})}
  def liftTermParamClause(y: scala.meta.Term.ParamClause) = '{scala.meta.Term.ParamClause(${Expr(y.values)}, ${Expr(y.mod)})}
  def liftTypeParamClause(y: scala.meta.Type.ParamClause) = '{scala.meta.Type.ParamClause(${Expr(y.values)})}
  def liftEnumeratorGenerator(y: scala.meta.Enumerator.Generator) = '{scala.meta.Enumerator.Generator(${Expr(y.pat)}, ${Expr(y.rhs)})}
  def liftEnumeratorCaseGenerator(y: scala.meta.Enumerator.CaseGenerator) = '{scala.meta.Enumerator.CaseGenerator(${Expr(y.pat)}, ${Expr(y.rhs)})}
  def liftEnumeratorVal(y: scala.meta.Enumerator.Val) = '{scala.meta.Enumerator.Val(${Expr(y.pat)}, ${Expr(y.rhs)})}
  def liftCase(y: scala.meta.Case) = '{scala.meta.Case(${Expr(y.pat)}, ${Expr(y.cond)}, ${Expr(y.body)})}
  def liftTypeCase(y: scala.meta.TypeCase) = '{scala.meta.TypeCase(${Expr(y.pat)}, ${Expr(y.body)})}
  def liftTypeParam(y: scala.meta.Type.Param) = '{scala.meta.Type.Param(${Expr(y.mods)}, ${Expr(y.name)}, ${Expr(y.tparamClause)}, ${Expr(y.tbounds)}, ${Expr(y.vbounds)}, ${Expr(y.cbounds)})}
  def liftTermParam(y: scala.meta.Term.Param) = '{scala.meta.Term.Param(${Expr(y.mods)}, ${Expr(y.name)}, ${Expr(y.decltpe)}, ${Expr(y.default)})}
  def liftSelf(y: scala.meta.Self) = '{scala.meta.Self(${Expr(y.name)}, ${Expr(y.decltpe)})}
  def liftCtorPrimary(y: scala.meta.Ctor.Primary) = '{scala.meta.Ctor.Primary(${Expr(y.mods)}, ${Expr(y.name)}, ${Expr(y.paramClauses)})}
  def liftModAnnot(y: scala.meta.Mod.Annot) = '{scala.meta.Mod.Annot(${Expr(y.init)})}
  def liftModPrivate(y: scala.meta.Mod.Private) = '{scala.meta.Mod.Private(${Expr(y.within)})}
  def liftModProtected(y: scala.meta.Mod.Protected) = '{scala.meta.Mod.Protected(${Expr(y.within)})}
  def liftModFinal(y: scala.meta.Mod.Final) = '{scala.meta.Mod.Final()}
  def liftModSealed(y: scala.meta.Mod.Sealed) = '{scala.meta.Mod.Sealed()}
  def liftModOpen(y: scala.meta.Mod.Open) = '{scala.meta.Mod.Open()}
  def liftModSuper(y: scala.meta.Mod.Super) = '{scala.meta.Mod.Super()}
  def liftModOverride(y: scala.meta.Mod.Override) = '{scala.meta.Mod.Override()}
  def liftModCase(y: scala.meta.Mod.Case) = '{scala.meta.Mod.Case()}
  def liftModAbstract(y: scala.meta.Mod.Abstract) = '{scala.meta.Mod.Abstract()}
  def liftModLazy(y: scala.meta.Mod.Lazy) = '{scala.meta.Mod.Lazy()}
  def liftModValParam(y: scala.meta.Mod.ValParam) = '{scala.meta.Mod.ValParam()}
  def liftModVarParam(y: scala.meta.Mod.VarParam) = '{scala.meta.Mod.VarParam()}
  def liftModInfix(y: scala.meta.Mod.Infix) = '{scala.meta.Mod.Infix()}
  def liftModInline(y: scala.meta.Mod.Inline) = '{scala.meta.Mod.Inline()}
  def liftModOpaque(y: scala.meta.Mod.Opaque) = '{scala.meta.Mod.Opaque()}
  def liftModTransparent(y: scala.meta.Mod.Transparent) = '{scala.meta.Mod.Transparent()}
  def liftModErased(y: scala.meta.Mod.Erased) = '{scala.meta.Mod.Erased()}
  def liftModImplicit(y: scala.meta.Mod.Implicit) = '{scala.meta.Mod.Implicit()}
  def liftModUsing(y: scala.meta.Mod.Using) = '{scala.meta.Mod.Using()}
  def liftModCovariant(y: scala.meta.Mod.Covariant) = '{scala.meta.Mod.Covariant()}
  def liftModContravariant(y: scala.meta.Mod.Contravariant) = '{scala.meta.Mod.Contravariant()}
  def liftEnumeratorGuard(y: scala.meta.Enumerator.Guard) = '{scala.meta.Enumerator.Guard(${Expr(y.cond)})}
  
  // Apparently the order here is important 
  def liftableSubTree0[T <: MetaTree](y: T)(using Quotes): Expr[T] = {
    val expr = y match {
      case (y @ (_: scala.meta.internal.trees.Quasi)) => liftQuasi(y.asInstanceOf[scala.meta.internal.trees.Quasi])
      case (y @ (_: scala.meta.Type.FuncParamClause)) => liftTypeFuncParamClause(y.asInstanceOf[scala.meta.Type.FuncParamClause])
      case (y @ (_: scala.meta.Type.Bounds)) => liftTypeBounds(y.asInstanceOf[scala.meta.Type.Bounds])
      case (y @ (_: scala.meta.Member.ParamClauseGroup)) => liftMemberParamClauseGroup(y.asInstanceOf[scala.meta.Member.ParamClauseGroup])
      case (y @ (_: scala.meta.Template)) => liftTemplate(y.asInstanceOf[scala.meta.Template])
      case (y @ (_: scala.meta.Importer)) => liftImporter(y.asInstanceOf[scala.meta.Importer])
      case (y @ (_: scala.meta.Source)) => liftSource(y.asInstanceOf[scala.meta.Source])
      case (y @ (_: scala.meta.MultiSource)) => liftMultiSource(y.asInstanceOf[scala.meta.MultiSource])
      case (y @ (_: scala.meta.Init)) => liftInit(y.asInstanceOf[scala.meta.Init])
      case (y @ (_: scala.meta.Name.Anonymous)) => liftNameAnonymous(y.asInstanceOf[scala.meta.Name.Anonymous])
      case (y @ (_: scala.meta.Name.This)) => liftNameThis(y.asInstanceOf[scala.meta.Name.This])
      case (y @ (_: scala.meta.Name.Indeterminate)) => liftNameIndeterminate(y.asInstanceOf[scala.meta.Name.Indeterminate])
      case (y @ (_: scala.meta.Name.Placeholder)) => liftNamePlaceholder(y.asInstanceOf[scala.meta.Name.Placeholder])
      case (y @ (_: scala.meta.Term.Name)) => liftTermName(y.asInstanceOf[scala.meta.Term.Name])
      case (y @ (_: scala.meta.Term.Anonymous)) => liftTermAnonymous(y.asInstanceOf[scala.meta.Term.Anonymous])
      case (y @ (_: scala.meta.Type.Name)) => liftTypeName(y.asInstanceOf[scala.meta.Type.Name])
      case (y @ (_: scala.meta.Term.This)) => liftTermThis(y.asInstanceOf[scala.meta.Term.This])
      case (y @ (_: scala.meta.Term.Super)) => liftTermSuper(y.asInstanceOf[scala.meta.Term.Super])
      case (y @ (_: scala.meta.Term.Select)) => liftTermSelect(y.asInstanceOf[scala.meta.Term.Select])
      case (y @ (_: scala.meta.Term.ApplyUnary)) => liftTermApplyUnary(y.asInstanceOf[scala.meta.Term.ApplyUnary])
      case (y @ (_: scala.meta.Type.Select)) => liftTypeSelect(y.asInstanceOf[scala.meta.Type.Select])
      case (y @ (_: scala.meta.Type.Project)) => liftTypeProject(y.asInstanceOf[scala.meta.Type.Project])
      case (y @ (_: scala.meta.Type.Singleton)) => liftTypeSingleton(y.asInstanceOf[scala.meta.Type.Singleton])
      case (y @ (_: scala.meta.Importee.Wildcard)) => liftImporteeWildcard(y.asInstanceOf[scala.meta.Importee.Wildcard])
      case (y @ (_: scala.meta.Importee.Given)) => liftImporteeGiven(y.asInstanceOf[scala.meta.Importee.Given])
      case (y @ (_: scala.meta.Importee.GivenAll)) => liftImporteeGivenAll(y.asInstanceOf[scala.meta.Importee.GivenAll])
      case (y @ (_: scala.meta.Importee.Name)) => liftImporteeName(y.asInstanceOf[scala.meta.Importee.Name])
      case (y @ (_: scala.meta.Importee.Rename)) => liftImporteeRename(y.asInstanceOf[scala.meta.Importee.Rename])
      case (y @ (_: scala.meta.Importee.Unimport)) => liftImporteeUnimport(y.asInstanceOf[scala.meta.Importee.Unimport])
      case (y @ (_: scala.meta.Type.AnonymousName)) => liftTypeAnonymousName(y.asInstanceOf[scala.meta.Type.AnonymousName])
      case (y @ (_: scala.meta.Type.Apply)) => liftTypeApply(y.asInstanceOf[scala.meta.Type.Apply])
      case (y @ (_: scala.meta.Type.ApplyInfix)) => liftTypeApplyInfix(y.asInstanceOf[scala.meta.Type.ApplyInfix])
      case (y @ (_: scala.meta.Type.PolyFunction)) => liftTypePolyFunction(y.asInstanceOf[scala.meta.Type.PolyFunction])
      case (y @ (_: scala.meta.Type.ImplicitFunction)) => liftTypeImplicitFunction(y.asInstanceOf[scala.meta.Type.ImplicitFunction])
      case (y @ (_: scala.meta.Type.Tuple)) => liftTypeTuple(y.asInstanceOf[scala.meta.Type.Tuple])
      case (y @ (_: scala.meta.Type.With)) => liftTypeWith(y.asInstanceOf[scala.meta.Type.With])
      case (y @ (_: scala.meta.Type.And)) => liftTypeAnd(y.asInstanceOf[scala.meta.Type.And])
      case (y @ (_: scala.meta.Type.Or)) => liftTypeOr(y.asInstanceOf[scala.meta.Type.Or])
      case (y @ (_: scala.meta.Type.Refine)) => liftTypeRefine(y.asInstanceOf[scala.meta.Type.Refine])
      case (y @ (_: scala.meta.Type.Existential)) => liftTypeExistential(y.asInstanceOf[scala.meta.Type.Existential])
      case (y @ (_: scala.meta.Type.Annotate)) => liftTypeAnnotate(y.asInstanceOf[scala.meta.Type.Annotate])
      case (y @ (_: scala.meta.Type.Lambda)) => liftTypeLambda(y.asInstanceOf[scala.meta.Type.Lambda])
      case (y @ (_: scala.meta.Type.AnonymousLambda)) => liftTypeAnonymousLambda(y.asInstanceOf[scala.meta.Type.AnonymousLambda])
      case (y @ (_: scala.meta.Type.Macro)) => liftTypeMacro(y.asInstanceOf[scala.meta.Type.Macro])
      case (y @ (_: scala.meta.Type.Method)) => liftTypeMethod(y.asInstanceOf[scala.meta.Type.Method])
      case (y @ (_: scala.meta.Type.PatWildcard)) => liftTypePatWildcard(y.asInstanceOf[scala.meta.Type.PatWildcard])
      case (y @ (_: scala.meta.Type.ByName)) => liftTypeByName(y.asInstanceOf[scala.meta.Type.ByName])
      case (y @ (_: scala.meta.Type.Repeated)) => liftTypeRepeated(y.asInstanceOf[scala.meta.Type.Repeated])
      case (y @ (_: scala.meta.Type.Var)) => liftTypeVar(y.asInstanceOf[scala.meta.Type.Var])
      case (y @ (_: scala.meta.Type.Match)) => liftTypeMatch(y.asInstanceOf[scala.meta.Type.Match])
      case (y @ (_: scala.meta.Lit.Null)) => liftLitNull(y.asInstanceOf[scala.meta.Lit.Null])
      case (y @ (_: scala.meta.Lit.Int)) => liftLitInt(y.asInstanceOf[scala.meta.Lit.Int])
      case (y @ (_: scala.meta.Lit.Double)) => liftLitDouble(y.asInstanceOf[scala.meta.Lit.Double])
      case (y @ (_: scala.meta.Lit.Float)) => liftLitFloat(y.asInstanceOf[scala.meta.Lit.Float])
      case (y @ (_: scala.meta.Lit.Byte)) => liftLitByte(y.asInstanceOf[scala.meta.Lit.Byte])
      case (y @ (_: scala.meta.Lit.Short)) => liftLitShort(y.asInstanceOf[scala.meta.Lit.Short])
      case (y @ (_: scala.meta.Lit.Char)) => liftLitChar(y.asInstanceOf[scala.meta.Lit.Char])
      case (y @ (_: scala.meta.Lit.Long)) => liftLitLong(y.asInstanceOf[scala.meta.Lit.Long])
      case (y @ (_: scala.meta.Lit.Boolean)) => liftLitBoolean(y.asInstanceOf[scala.meta.Lit.Boolean])
      case (y @ (_: scala.meta.Lit.Unit)) => liftLitUnit(y.asInstanceOf[scala.meta.Lit.Unit])
      case (y @ (_: scala.meta.Lit.String)) => liftLitString(y.asInstanceOf[scala.meta.Lit.String])
      // case (y @ (_: scala.meta.Lit.Symbol)) => liftLitSymbol(y.asInstanceOf[scala.meta.Lit.Symbol])
      case (y @ (_: scala.meta.Type.Function)) => liftTypeFunction(y.asInstanceOf[scala.meta.Type.Function])
      case (y @ (_: scala.meta.Type.ContextFunction)) => liftTypeContextFunction(y.asInstanceOf[scala.meta.Type.ContextFunction])
      case (y @ (_: scala.meta.Type.Placeholder.Impl)) => liftTypePlaceholderImpl(y.asInstanceOf[scala.meta.Type.Placeholder.Impl])
      case (y @ (_: scala.meta.Type.Wildcard)) => liftTypeWildcard(y.asInstanceOf[scala.meta.Type.Wildcard])
      case (y @ (_: scala.meta.Type.AnonymousParam)) => liftTypeAnonymousParam(y.asInstanceOf[scala.meta.Type.AnonymousParam])
      case (y @ (_: scala.meta.Type.TypedParam)) => liftTypeTypedParam(y.asInstanceOf[scala.meta.Type.TypedParam])
      case (y @ (_: scala.meta.Type.FunctionArg)) => liftTypeFunctionArg(y.asInstanceOf[scala.meta.Type.FunctionArg])
      case (y @ (_: scala.meta.Pat.Var)) => liftPatVar(y.asInstanceOf[scala.meta.Pat.Var])
      case (y @ (_: scala.meta.Pat.Wildcard)) => liftPatWildcard(y.asInstanceOf[scala.meta.Pat.Wildcard])
      case (y @ (_: scala.meta.Pat.SeqWildcard)) => liftPatSeqWildcard(y.asInstanceOf[scala.meta.Pat.SeqWildcard])
      case (y @ (_: scala.meta.Pat.Bind)) => liftPatBind(y.asInstanceOf[scala.meta.Pat.Bind])
      case (y @ (_: scala.meta.Pat.Alternative)) => liftPatAlternative(y.asInstanceOf[scala.meta.Pat.Alternative])
      case (y @ (_: scala.meta.Pat.Tuple)) => liftPatTuple(y.asInstanceOf[scala.meta.Pat.Tuple])
      case (y @ (_: scala.meta.Pat.Repeated)) => liftPatRepeated(y.asInstanceOf[scala.meta.Pat.Repeated])
      case (y @ (_: scala.meta.Pat.Extract)) => liftPatExtract(y.asInstanceOf[scala.meta.Pat.Extract])
      case (y @ (_: scala.meta.Pat.ExtractInfix)) => liftPatExtractInfix(y.asInstanceOf[scala.meta.Pat.ExtractInfix])
      case (y @ (_: scala.meta.Pat.Interpolate)) => liftPatInterpolate(y.asInstanceOf[scala.meta.Pat.Interpolate])
      case (y @ (_: scala.meta.Pat.Xml)) => liftPatXml(y.asInstanceOf[scala.meta.Pat.Xml])
      case (y @ (_: scala.meta.Pat.Typed)) => liftPatTyped(y.asInstanceOf[scala.meta.Pat.Typed])
      case (y @ (_: scala.meta.Pat.Macro)) => liftPatMacro(y.asInstanceOf[scala.meta.Pat.Macro])
      case (y @ (_: scala.meta.Pat.Given)) => liftPatGiven(y.asInstanceOf[scala.meta.Pat.Given])
      case (y @ (_: scala.meta.Pkg)) => liftPkg(y.asInstanceOf[scala.meta.Pkg])
      case (y @ (_: scala.meta.Pkg.Object)) => liftPkgObject(y.asInstanceOf[scala.meta.Pkg.Object])
      case (y @ (_: scala.meta.Ctor.Secondary)) => liftCtorSecondary(y.asInstanceOf[scala.meta.Ctor.Secondary])
      case (y @ (_: scala.meta.Term.Interpolate)) => liftTermInterpolate(y.asInstanceOf[scala.meta.Term.Interpolate])
      case (y @ (_: scala.meta.Term.Xml)) => liftTermXml(y.asInstanceOf[scala.meta.Term.Xml])
      case (y @ (_: scala.meta.Term.Apply)) => liftTermApply(y.asInstanceOf[scala.meta.Term.Apply])
      case (y @ (_: scala.meta.Term.ApplyUsing)) => liftTermApplyUsing(y.asInstanceOf[scala.meta.Term.ApplyUsing])
      case (y @ (_: scala.meta.Term.ApplyType)) => liftTermApplyType(y.asInstanceOf[scala.meta.Term.ApplyType])
      case (y @ (_: scala.meta.Term.ApplyInfix)) => liftTermApplyInfix(y.asInstanceOf[scala.meta.Term.ApplyInfix])
      case (y @ (_: scala.meta.Term.Assign)) => liftTermAssign(y.asInstanceOf[scala.meta.Term.Assign])
      case (y @ (_: scala.meta.Term.Return)) => liftTermReturn(y.asInstanceOf[scala.meta.Term.Return])
      case (y @ (_: scala.meta.Term.Throw)) => liftTermThrow(y.asInstanceOf[scala.meta.Term.Throw])
      case (y @ (_: scala.meta.Term.Ascribe)) => liftTermAscribe(y.asInstanceOf[scala.meta.Term.Ascribe])
      case (y @ (_: scala.meta.Term.Annotate)) => liftTermAnnotate(y.asInstanceOf[scala.meta.Term.Annotate])
      case (y @ (_: scala.meta.Term.Tuple)) => liftTermTuple(y.asInstanceOf[scala.meta.Term.Tuple])
      case (y @ (_: scala.meta.Term.Block)) => liftTermBlock(y.asInstanceOf[scala.meta.Term.Block])
      case (y @ (_: scala.meta.Term.EndMarker)) => liftTermEndMarker(y.asInstanceOf[scala.meta.Term.EndMarker])
      case (y @ (_: scala.meta.Term.If)) => liftTermIf(y.asInstanceOf[scala.meta.Term.If])
      case (y @ (_: scala.meta.Term.QuotedMacroExpr)) => liftTermQuotedMacroExpr(y.asInstanceOf[scala.meta.Term.QuotedMacroExpr])
      case (y @ (_: scala.meta.Term.QuotedMacroType)) => liftTermQuotedMacroType(y.asInstanceOf[scala.meta.Term.QuotedMacroType])
      case (y @ (_: scala.meta.Term.SplicedMacroExpr)) => liftTermSplicedMacroExpr(y.asInstanceOf[scala.meta.Term.SplicedMacroExpr])
      case (y @ (_: scala.meta.Term.SplicedMacroPat)) => liftTermSplicedMacroPat(y.asInstanceOf[scala.meta.Term.SplicedMacroPat])
      case (y @ (_: scala.meta.Term.Match)) => liftTermMatch(y.asInstanceOf[scala.meta.Term.Match])
      case (y @ (_: scala.meta.Term.Try)) => liftTermTry(y.asInstanceOf[scala.meta.Term.Try])
      case (y @ (_: scala.meta.Term.TryWithHandler)) => liftTermTryWithHandler(y.asInstanceOf[scala.meta.Term.TryWithHandler])
      case (y @ (_: scala.meta.Term.AnonymousFunction)) => liftTermAnonymousFunction(y.asInstanceOf[scala.meta.Term.AnonymousFunction])
      case (y @ (_: scala.meta.Term.PolyFunction)) => liftTermPolyFunction(y.asInstanceOf[scala.meta.Term.PolyFunction])
      case (y @ (_: scala.meta.Term.PartialFunction)) => liftTermPartialFunction(y.asInstanceOf[scala.meta.Term.PartialFunction])
      case (y @ (_: scala.meta.Term.While)) => liftTermWhile(y.asInstanceOf[scala.meta.Term.While])
      case (y @ (_: scala.meta.Term.Do)) => liftTermDo(y.asInstanceOf[scala.meta.Term.Do])
      case (y @ (_: scala.meta.Term.For)) => liftTermFor(y.asInstanceOf[scala.meta.Term.For])
      case (y @ (_: scala.meta.Term.ForYield)) => liftTermForYield(y.asInstanceOf[scala.meta.Term.ForYield])
      case (y @ (_: scala.meta.Term.New)) => liftTermNew(y.asInstanceOf[scala.meta.Term.New])
      case (y @ (_: scala.meta.Term.NewAnonymous)) => liftTermNewAnonymous(y.asInstanceOf[scala.meta.Term.NewAnonymous])
      case (y @ (_: scala.meta.Term.Placeholder)) => liftTermPlaceholder(y.asInstanceOf[scala.meta.Term.Placeholder])
      case (y @ (_: scala.meta.Term.Eta)) => liftTermEta(y.asInstanceOf[scala.meta.Term.Eta])
      case (y @ (_: scala.meta.Term.Repeated)) => liftTermRepeated(y.asInstanceOf[scala.meta.Term.Repeated])
      case (y @ (_: scala.meta.Term.ContextFunction)) => liftTermContextFunction(y.asInstanceOf[scala.meta.Term.ContextFunction])
      case (y @ (_: scala.meta.Term.Function)) => liftTermFunction(y.asInstanceOf[scala.meta.Term.Function])
      case (y @ (_: scala.meta.Defn.Given)) => liftDefnGiven(y.asInstanceOf[scala.meta.Defn.Given])
      case (y @ (_: scala.meta.Defn.Enum)) => liftDefnEnum(y.asInstanceOf[scala.meta.Defn.Enum])
      case (y @ (_: scala.meta.Defn.Class)) => liftDefnClass(y.asInstanceOf[scala.meta.Defn.Class])
      case (y @ (_: scala.meta.Defn.Trait)) => liftDefnTrait(y.asInstanceOf[scala.meta.Defn.Trait])
      case (y @ (_: scala.meta.Defn.Object)) => liftDefnObject(y.asInstanceOf[scala.meta.Defn.Object])
      case (y @ (_: scala.meta.Decl.Val)) => liftDeclVal(y.asInstanceOf[scala.meta.Decl.Val])
      case (y @ (_: scala.meta.Decl.Var)) => liftDeclVar(y.asInstanceOf[scala.meta.Decl.Var])
      case (y @ (_: scala.meta.Decl.Def)) => liftDeclDef(y.asInstanceOf[scala.meta.Decl.Def])
      case (y @ (_: scala.meta.Decl.Type)) => liftDeclType(y.asInstanceOf[scala.meta.Decl.Type])
      case (y @ (_: scala.meta.Decl.Given)) => liftDeclGiven(y.asInstanceOf[scala.meta.Decl.Given])
      case (y @ (_: scala.meta.Defn.Val)) => liftDefnVal(y.asInstanceOf[scala.meta.Defn.Val])
      case (y @ (_: scala.meta.Defn.Var)) => liftDefnVar(y.asInstanceOf[scala.meta.Defn.Var])
      case (y @ (_: scala.meta.Defn.EnumCase)) => liftDefnEnumCase(y.asInstanceOf[scala.meta.Defn.EnumCase])
      case (y @ (_: scala.meta.Defn.RepeatedEnumCase)) => liftDefnRepeatedEnumCase(y.asInstanceOf[scala.meta.Defn.RepeatedEnumCase])
      case (y @ (_: scala.meta.Defn.GivenAlias)) => liftDefnGivenAlias(y.asInstanceOf[scala.meta.Defn.GivenAlias])
      case (y @ (_: scala.meta.Defn.Def)) => liftDefnDef(y.asInstanceOf[scala.meta.Defn.Def])
      case (y @ (_: scala.meta.Defn.Macro)) => liftDefnMacro(y.asInstanceOf[scala.meta.Defn.Macro])
      case (y @ (_: scala.meta.Defn.Type)) => liftDefnType(y.asInstanceOf[scala.meta.Defn.Type])
      case (y @ (_: scala.meta.Defn.ExtensionGroup)) => liftDefnExtensionGroup(y.asInstanceOf[scala.meta.Defn.ExtensionGroup])
      case (y @ (_: scala.meta.Import)) => liftImport(y.asInstanceOf[scala.meta.Import])
      case (y @ (_: scala.meta.Export)) => liftExport(y.asInstanceOf[scala.meta.Export])
      case (y @ (_: scala.meta.Term.ArgClause)) => liftTermArgClause(y.asInstanceOf[scala.meta.Term.ArgClause])
      case (y @ (_: scala.meta.Type.ArgClause)) => liftTypeArgClause(y.asInstanceOf[scala.meta.Type.ArgClause])
      case (y @ (_: scala.meta.Pat.ArgClause)) => liftPatArgClause(y.asInstanceOf[scala.meta.Pat.ArgClause])
      case (y @ (_: scala.meta.Term.ParamClause)) => liftTermParamClause(y.asInstanceOf[scala.meta.Term.ParamClause])
      case (y @ (_: scala.meta.Type.ParamClause)) => liftTypeParamClause(y.asInstanceOf[scala.meta.Type.ParamClause])
      case (y @ (_: scala.meta.Enumerator.Generator)) => liftEnumeratorGenerator(y.asInstanceOf[scala.meta.Enumerator.Generator])
      case (y @ (_: scala.meta.Enumerator.CaseGenerator)) => liftEnumeratorCaseGenerator(y.asInstanceOf[scala.meta.Enumerator.CaseGenerator])
      case (y @ (_: scala.meta.Enumerator.Val)) => liftEnumeratorVal(y.asInstanceOf[scala.meta.Enumerator.Val])
      case (y @ (_: scala.meta.Case)) => liftCase(y.asInstanceOf[scala.meta.Case])
      case (y @ (_: scala.meta.TypeCase)) => liftTypeCase(y.asInstanceOf[scala.meta.TypeCase])
      case (y @ (_: scala.meta.Type.Param)) => liftTypeParam(y.asInstanceOf[scala.meta.Type.Param])
      case (y @ (_: scala.meta.Term.Param)) => liftTermParam(y.asInstanceOf[scala.meta.Term.Param])
      case (y @ (_: scala.meta.Self)) => liftSelf(y.asInstanceOf[scala.meta.Self])
      case (y @ (_: scala.meta.Ctor.Primary)) => liftCtorPrimary(y.asInstanceOf[scala.meta.Ctor.Primary])
      case (y @ (_: scala.meta.Mod.Annot)) => liftModAnnot(y.asInstanceOf[scala.meta.Mod.Annot])
      case (y @ (_: scala.meta.Mod.Private)) => liftModPrivate(y.asInstanceOf[scala.meta.Mod.Private])
      case (y @ (_: scala.meta.Mod.Protected)) => liftModProtected(y.asInstanceOf[scala.meta.Mod.Protected])
      case (y @ (_: scala.meta.Mod.Final)) => liftModFinal(y.asInstanceOf[scala.meta.Mod.Final])
      case (y @ (_: scala.meta.Mod.Sealed)) => liftModSealed(y.asInstanceOf[scala.meta.Mod.Sealed])
      case (y @ (_: scala.meta.Mod.Open)) => liftModOpen(y.asInstanceOf[scala.meta.Mod.Open])
      case (y @ (_: scala.meta.Mod.Super)) => liftModSuper(y.asInstanceOf[scala.meta.Mod.Super])
      case (y @ (_: scala.meta.Mod.Override)) => liftModOverride(y.asInstanceOf[scala.meta.Mod.Override])
      case (y @ (_: scala.meta.Mod.Case)) => liftModCase(y.asInstanceOf[scala.meta.Mod.Case])
      case (y @ (_: scala.meta.Mod.Abstract)) => liftModAbstract(y.asInstanceOf[scala.meta.Mod.Abstract])
      case (y @ (_: scala.meta.Mod.Lazy)) => liftModLazy(y.asInstanceOf[scala.meta.Mod.Lazy])
      case (y @ (_: scala.meta.Mod.ValParam)) => liftModValParam(y.asInstanceOf[scala.meta.Mod.ValParam])
      case (y @ (_: scala.meta.Mod.VarParam)) => liftModVarParam(y.asInstanceOf[scala.meta.Mod.VarParam])
      case (y @ (_: scala.meta.Mod.Infix)) => liftModInfix(y.asInstanceOf[scala.meta.Mod.Infix])
      case (y @ (_: scala.meta.Mod.Inline)) => liftModInline(y.asInstanceOf[scala.meta.Mod.Inline])
      case (y @ (_: scala.meta.Mod.Opaque)) => liftModOpaque(y.asInstanceOf[scala.meta.Mod.Opaque])
      case (y @ (_: scala.meta.Mod.Transparent)) => liftModTransparent(y.asInstanceOf[scala.meta.Mod.Transparent])
      case (y @ (_: scala.meta.Mod.Erased)) => liftModErased(y.asInstanceOf[scala.meta.Mod.Erased])
      case (y @ (_: scala.meta.Mod.Implicit)) => liftModImplicit(y.asInstanceOf[scala.meta.Mod.Implicit])
      case (y @ (_: scala.meta.Mod.Using)) => liftModUsing(y.asInstanceOf[scala.meta.Mod.Using])
      case (y @ (_: scala.meta.Mod.Covariant)) => liftModCovariant(y.asInstanceOf[scala.meta.Mod.Covariant])
      case (y @ (_: scala.meta.Mod.Contravariant)) => liftModContravariant(y.asInstanceOf[scala.meta.Mod.Contravariant])
      case (y @ (_: scala.meta.Enumerator.Guard)) => liftEnumeratorGuard(y.asInstanceOf[scala.meta.Enumerator.Guard])
      case _ => sys.error("none of leafs matched " + (y.getClass))
    }
    expr.asInstanceOf[Expr[T]]
  }
}